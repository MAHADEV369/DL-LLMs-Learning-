import numpy as np

def leaky_relu(x, alpha=0.2):
    return np.where(x >= 0, x, alpha * x)

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def discriminator_forward(x, weights, biases):
    """
    Forward pass for a linear discriminator.

    Args:
        x (np.ndarray): Input data, shape (batch_size, input_dim)
        weights (list): List of weight matrices [W_0, ..., W_{N-1}]
        biases (list): List of bias vectors [b_0, ..., b_{N-1}]

    Returns:
        output (np.ndarray): Probability input is real, shape (batch_size, 1)
        activations (list): List of activations [h_0, ..., h_N]
    """
    activations = [x]
    h = x

    num_layers = len(weights)

    for i in range(num_layers):
        z = h @ weights[i] + biases[i]

        if i < num_layers - 1:
            h = leaky_relu(z)
        else:
            h = sigmoid(z)

        activations.append(h)

    output = h
    return output, activations




#Discriminator Forward Pass (Linear)
#Implement the forward pass of a Discriminator network. The goal of the discriminator is to distinguish between real data and fake data generated by the generator.
